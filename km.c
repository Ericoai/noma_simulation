#include<iostream>
#include <windows.h>
#include <stdio.h>
#include <windef.h>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=110;
const int inf=0x7fffffff;
int n = 10,m = 10;
int w[maxn][maxn] ={{0,0,0,0,0,0,0,0,0,0,0},{0,0.000,13.609,	2.265,	5.537,	12.844,	1.619,	4.904,	1.487,	2.891,	5.296},{0,13.609,	0.000,	15.873,	19.145,	0.764,	11.990,	18.512,	15.096,	16.500,	18.904},{0,2.265,	15.873,	0.000,	3.272,	15.109,	3.883,	2.639,	0.778,	0.626,	3.031},{0,5.537,	19.145,	3.272,	0.000,	18.381,	7.155,	0.633,	4.050,	2.646,	0.241},{0,12.844,	0.764,	15.109,	18.381,	0.000,	11.226,	17.748,	14.331,	15.735,	18.140},{0,1.619,	11.990,	3.883,	7.155,	11.226,	0.000,	6.522,	3.106,	4.509,	6.914},{0,4.904,	18.512,	2.639,	0.633,	17.748,	6.522,	0.000,	3.417,	2.013,	0.392},{0,1.487,	15.096,	0.778,	4.050,	14.331,	3.106,	3.417,	0.000,	1.404,	3.809},{0,2.891,	16.500,	0.626,	2.646,	15.735,	4.509,	2.013,	1.404,	0.000,	2.405},{0,5.296,	18.904,	3.031,	0.241,	18.140,	6.914,	0.392,	3.809,	2.405,	0.000}};//n表示x边点的个数，y表示y边点的个数，w表示边权值
int lx[maxn],ly[maxn];//lx表示x边的标杆，ly表示y边的标杆
int from[maxn],to[maxn];//from[i]=j表示y边的i由x边的j连接。to[i]=j表示x边的i可以到达y边的j
bool s[maxn],t[maxn];//s表示x边的点集，t表示y边的点集
bool find(int x)//匈牙利算法
{
    s[x]=1;
    for(int i=1;i<=m;i++)
    if(lx[x]+ly[i]==w[x][i]&&!t[i])
    {
        t[i]=1;
        if(!from[i]||find(from[i]))
        {
            from[i]=x;
            to[x]=i;
            return 1;
        }
    }
    return 0;
}
void update()//更新标杆
{
    int d=inf;
    for(int i=1;i<=n;i++)
    if(s[i])
    for(int j=1;j<=m;j++)
    if(!t[j])
    d=min(d,lx[i]+ly[j]-w[i][j]);//按照上面给出的原则计算d
    for(i=1;i<=n;i++)//点集s中的点的标杆lx[i]-d
    if(s[i]) lx[i]-=d;
    for(int j=1;j<=m;j++)//点集t中的点的标杆ly[j]+d
    if(t[j]) ly[j]+=d;
}
void km()//km算法
{
    for(int i=1;i<=n;i++)//初始化标杆
      for(int j=1;j<=m;j++)
      lx[i]=max(lx[i],w[i][j]);
    for(i=1;i<=n;i++)//x边每个点的匹配
    for(;;)
    {
        memset(s,0,sizeof(s));
        memset(t,0,sizeof(t));
        if(find(i)) break;
        else update();
    }
}
int main()
{

    //scanf("%d %d",&n,&m);//输入
	int n = 10;
	int m = 10;
	/*
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
      scanf("%d",&w[i][j]);
	*/
	int w[11][11] = {{0,0,0,0,0,0,0,0,0,0,0},{0,0.000,13.609,	2.265,	5.537,	12.844,	1.619,	4.904,	1.487,	2.891,	5.296},{0,13.609,	0.000,	15.873,	19.145,	0.764,	11.990,	18.512,	15.096,	16.500,	18.904},{0,2.265,	15.873,	0.000,	3.272,	15.109,	3.883,	2.639,	0.778,	0.626,	3.031},{0,5.537,	19.145,	3.272,	0.000,	18.381,	7.155,	0.633,	4.050,	2.646,	0.241},{0,12.844,	0.764,	15.109,	18.381,	0.000,	11.226,	17.748,	14.331,	15.735,	18.140},{0,1.619,	11.990,	3.883,	7.155,	11.226,	0.000,	6.522,	3.106,	4.509,	6.914},{0,4.904,	18.512,	2.639,	0.633,	17.748,	6.522,	0.000,	3.417,	2.013,	0.392},{0,1.487,	15.096,	0.778,	4.050,	14.331,	3.106,	3.417,	0.000,	1.404,	3.809},{0,2.891,	16.500,	0.626,	2.646,	15.735,	4.509,	2.013,	1.404,	0.000,	2.405},{0,5.296,	18.904,	3.031,	0.241,	18.140,	6.914,	0.392,	3.809,	2.405,	0.000}};
    km();
    int ans=0;
    for(int i=1;i<=n;i++)//计算答案
	{
		ans+=w[i][to[i]];
		printf("%d\n",w[i][to[i]]);

	}
    printf("%d\n",ans);//输出
    return 0;
}
